


---------------------------------------------1.位运算------------------------------
异或运算
内容：
异或运算的性质
异或运算的题目
a = 甲 ^ 乙   b = 乙
b = 甲 ^ 乙 ^ 乙  = 甲 ^ 0 = 甲
a = 甲 ^ 乙 ^ 甲  = 乙 ^ 甲 ^ 甲 =乙

题目：
1、变量的32位打印 怎么把一个int类型的数，提取出二进制中最右侧的1来
2、不用额外变量交换两个数的值  不用额外变量交换数组中两个数的值
3、一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数
4、一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数
5、一个数组中有一种数出现K次，其他数都出现了M次， 已知M > 1，K < M，找到出现了K次的数 要求额外空间复杂度O(1)，时间复杂度O(N)
6、位运算实现加减乘除




---------------------------------------------2、递归------------------------------


递归的物理实质
评估递归复杂度的Master公式
用递归行为得到数组中的最大值，并用master公式来估计时间复杂度






---------------------------------------------3、搜索------------------------------



二分法
题目：
1、有序数组中找到num
2、有序数组中找到>=num最左的位置
有序数组中找到<=num最右的位置
3、局部最小值问题


局部最小值问题
定义何为局部最小值：
arr[0] < arr[1]，0位置是局部最小；
arr[N-1] < arr[N-2]，N-1位置是局部最小；
arr[i-1] > arr[i] < arr[i+1]，i位置是局部最小；
给定一个数组arr，已知任何两个相邻的数都不相等，找到随便一个局部最小位置返回


Hash:
哈希表
有序表




---------------------------------------------4、排序------------------------------
冒泡、选择、插入排序





---------------------------------------------贪心算法------------------------------






---------------------------------------------动态规划------------------------------
内容：

暴力递归和动态规划的关系
记忆化搜索
动态规划都可以由暴力递归改进过来，解决动态规划的套路

常见的尝试模型
设计尝试过程的原则






---------------------------------------------KMP算法------------------------------

和KMP算法相关的面试题

题目：
KMP算法实现
给定两棵二叉树的头节点head1和head2，返回head1中是否有某个子树的结构和head2完全一样
判断str1和str2是否互为旋转字符串



---------------------------------------------Manacher算法------------------------------

内容：
Manacher算法
和Manacher算法相关的面试题

题目：
Manacher算法实现
给定一个字符串str，只能在str的后面添加字符，想让str整体变成回文串，返回至少要添加几个字符




---------------------------------------------蓄水池算法------------------------------
在无序数组中找到第K小的数

内容：
时间复杂度O(N)可以解决在无序数组中找到第K小的数，这个经典的面试题

改写快排的partition方法
bfprt算法
蓄水池算法

题目：
在无序数组中找到第K小的数（改写快排+bfprt）
设计在无序数组中收集最大的前K个数字的算法（根据不同的三个时间复杂度，设计三个算法）
给定一个无序数组arr中，长度为N，给定一个正数k，返回top k个最大的数
不同时间复杂度三个方法：
1）O(N*logN)
2）O(N + K*logN)
3）O(n + k*logk)
历



---------------------------------------------Morris遍------------------------------


二叉树之前的遍历方式有空间浪费的问题
Morris遍历时间复杂度O(N)，额外空间复杂度O(1)，通过利用原树中大量空闲指针的方式，达到节省空间的目的
